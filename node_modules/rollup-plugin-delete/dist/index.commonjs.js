'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var internalDel = _interopDefault(require('del'));

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function del(options = {}) {
  const {
    hook = 'buildStart',
    targets = [],
    verbose = false
  } = options,
        rest = _objectWithoutProperties(options, ["hook", "targets", "verbose"]);

  return {
    name: 'delete',
    [hook]: () => internalDel(targets, rest).then(paths => {
      if (verbose || rest.dryRun) {
        const message = rest.dryRun ? `Expected files and folders to be deleted: ${paths.length}` : `Deleted files and folders: ${paths.length}`;
        console.log(message);

        if (paths.length > 0) {
          paths.forEach(path => {
            console.log(path);
          });
        }
      }
    })
  };
}

module.exports = del;
